---
title: 计算机操作系统（8）：进程通信与死锁
type: tags
tags:
  - null
date: 2019-03-05 17:53:14
categories:
description:
---

# 死锁

进程间由于共享资源所导致的一种无限期等待的情况

## 概念

由于竞争资源或者通信关系，两个或者更多线程在执行中出现，永远相互等待只能由其他进程引发的事件

**进程访问资源的流程**

- 资源类型 
  - CPU执行时间、内存空间、IO设备等
- 每类资源R有W个实例
- 进程访问资源的流程
  - 请求/获取
  - 使用/占用
  - 释放

**资源分类**

- 可重用资源
  - 资源不能被删除，且任何时刻只能有一个进程使用
  - 进程释放资源后，其他进程可重用
  - 可重用资源示例
    - 硬件：处理器、IO、主和副存储器、设备等
    - 软件：文件、数据库、信号量等数据结构
  - 可能出现死锁
    - 一个进程占用一部分资源并请求其他资源
- 消耗资源
  - 资源创建和销毁
  - 销毁资源示例：
    - 在IO缓冲区的中断、信号、消息等
  - 可能出现死锁
    - 进程间相互等待接收对方的消息

**资源分配图**

描述资源和进程间的分配和占用关系的有向图

- 两类定点
  - 系统中的所有进程P
  - 系统中的所有资源R
- 两类有向边
  - 资源请求边P->R
  - 资源分配边R->P

存在死锁的分配图：

![1551948669788](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551948669788.png)

**出现死锁的必要条件**

- 互斥：任何时刻只能有一个进程使用一个资源实例
- 持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源
- 非抢占：资源只能再进程使用后自愿释放
- 循环等待：存在等待进程集合，形成循环

## 处理方法

类似于消防系统

- 死锁预防
  - 确保系统永远不会进入死锁状态
  - 资源利用效率可能较低
- 死锁避免
  - 使用前进行判断，只允许不会出现死锁的进程请求资源
- 死锁检测和恢复
  - 在检测到运行系统进入死锁状态后，进行恢复
- 由应用进程处理死锁
  - 通常操作系统忽略死锁的存在

**死锁预防**

预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件

- 互斥：把互斥的共享资源封装成可同时访问
- 持有并等待：
  - 进程请求资源时，要求它不能持有任何其他资源
  - 仅允许进程在开始执行时，一次请求所有需要的资源
  - 资源利用率低
- 非抢占：
  - 如进程请求不能立即分配的资源，则释放已占有资源
  - 只有能同时获得所有需要资源时，才执行分配操作
- 循环等待：对资源排序，要求进程按顺序请求资源

**死锁避免**

- 利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源
  - 要求进程声明需要的资源的最大数目
  - 限定提供与分配的资源数量，确保满足进程的最大需求
  - 动态检查资源分配状态，确保不会出现环路等待
    - 系统资源分配的安全状态
    - 进行执行的安全序列

## 银行家算法

一种死锁避免的方法，以银行借贷分配策略为基础，判断并保证系统处于安全状态

问题模型：

![1551949424265](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551949424265.png)

数据结构

![1551949511055](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551949511055.png)

## 死锁检测

- 允许系统进入死锁状态
- 维护系统的资源分配图
- 定期调用死锁检测算法来搜索图红是非存在死锁
- 出现死锁使用死锁恢复机制

![1551949623989](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551949623989.png)

死锁检测算法的使用

- 检测的时间和周期选择依据
  - 死锁多久可能会发生
  - 多少进程需要被回滚
- 资源图可能有多个循环
  - 难于分辨造成死锁的关键进程

## 死锁恢复

进程终止

- 终止所有的死锁进程
- 一次只终止一个进程直到死锁消除
- 终止进程的顺序应该是
  - 进程的优先级
  - 进程已运行时间以及还需运行时间
  - 进程已占有资源
  - 进程完成需要的资源
  - 终止进程数目
  - 进程是交互还是批处理

资源抢占

- 选择被抢占进程
  - 最小成本目标
- 进程回退
  - 返回到一些安全状态，重启进程到安全状态
- 可能出现饥饿
  - 同一进程可能一直被抢占

# 进程通信 IPC

进程通信是进程进行通信和同步的机制

IPC提供2个基本操作

- 发送操作send
- 接受操作receive

进程通信流程

- 在通信进程间建立通信链路
- 通过方法send/receive

进程链路特征

- 物理：物理内存，硬件总线等
- 逻辑：逻辑属性等

**通信方式**

- 间接通信
  - 依赖操作系统内核完成进程间腾讯
  - 在通信进程和内核当中建立相应的机构
    - 消息队列
    - 在进程A通信时，进程B可以未创建
- 直接通信
  - 在两个进程间建立一个共享信道
    - 两个进程必须同时存在
- ![1551950132700](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551950132700.png)

**直接通信**

- 进程必须正确命名对方
  - send发送信息到进程P
  - receive从进程Q接受消息
- 通信链路的属性
  - 自动建立链路
  - 一条链路恰好对应一对通信进程
  - 每对进程间只有一个链接存在
  - 链路可以是单向也可以是双向

**间接通信**

- 通过操作系统维护的消息队列实现进程间的消息接受和发送
  - 每个消息队列有一个唯一的标识
  - 只有共享了相同消息队列的进程，才能通信
- 链路属性
  - 只有共享了相同消息队列的进程，才能建立连接
  - 连接可以是单向也可以是双向
  - 消息队列可以与多个进程相关联
  - 每对进程可以共享多个消息队列
- 通信流程
  - 创建一个新的消息队列
  - 通过消息队列发送和接受消息
  - 销毁消息队列

**阻塞与非阻塞通信**

进程通信可划分为阻塞（同步）或非阻塞（异步）

- 阻塞通信
  - 阻塞发送：发送者在发送消息后进入等待，直到接受者成功收到
  - 阻塞接受：接受方在请求接受消息后进入等待，直到成功接受
- 非阻塞
  - 非阻塞发送：发送者在消息发送后，可立即进行其他操作
  - 非阻塞接受：不会等待接受

**通信链路缓冲**

进程发送的消息在链路上可能与3中缓冲方式

- 0容量，发送方必须等待接收方
- 有限容量。通信链路缓冲队列满时，发送方必须等待
- 无限容量。发送方不需要等待

## 信号

操作系统提供，一种快速地通信机制

- 进程间的软件中断通知和处理机制

信号的接受处理

- 捕获：执行进程制定的信号处理函数被调用(软件定义)
- 忽略：执行操作系统制定的缺省处理（进程注册时，操作系统注册处理函数）
  - Ctrl C
- 屏蔽：禁止进程接受和处理信号
  - 可能是暂时的

不足：传递的信息量小，只有一个信号类型

## 管道

操作系统提供

- 进程间基于内存文件的通信机制
  - 子进程从父进程继承文件描述符
  - 缺省文件描述符：0 stdin 1 stdout 2stderr
- 进程不关心另一端
  - 可能从键盘、文件、程序读取
  - 可能写入到终端、文件、程序
- 读管道：read（）,scanf（）
- 写管道：write(),printf（）
- 创建管道 pipe

## 消息队列

- 消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制
  - 每个消息是一个字节序列
  - 相同标识的消息组成按先进先出顺序组成一个消息队列
- 消息队列的系统调用
  - msgget获得消息队列标识
  - msgsnd发送消息
  - msgrcv接受消息
  - msgctl消息队列控制

## 共享内存

- 共享内存是把同一个物理内存区域同时映射到多个进程的内存地址的通信机制
- 进程
  - 每个进程都有私有内存地址空间
  - 每个进程的内存地址空间需要明确设置共享内存段
- 线程：同一进程中的线程总是共享相同的内存地址空间
- 优点：快速、方便地共享数据
- 缺点：必须用额外的同步机制

依据页表项进行映射

- 最快的方法
- 一个进程写，另一个进程立即可见
- 没有系统调用干预
- 没有数据复制
- 不提供同步，需要程序员进行同步


# 参考 #

1. 

---
title: 计算机操作系统：进程和线程
type: tags
tags:
  - 操作系统
date: 2019-03-03 23:07:10
categories: OS
description:
---

# 进程

## 进程的概念

**出现原因**

早期OS只允许 一次执行一个程序，现代OS允许将多个程序调入内存并发执行。要求对各种程序提供更为严格的控制和更好地划分。

**概述**

进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

- 即程序本身不是进程，程序只是被动实体（一个可执行文件），而进程是活动实体，拥有一个程序计数器用来表示下一个要执行的命令和相关资源集合。
- 当一个可执行文件装入内存，一个程序才能成为进程

![1551625950390](assets/1551625950390.png)



**进程的组成**

- 进程包含了正在运行的一个程序的所有状态信息
  - 程序代码。即可执行文件
  - 数据。进程通常还包括进程堆栈段（临时数据，如函数参数、返回地址和局部变量）和数据段（全局变量等）
  - 可能包括堆，是在进程运行期间动态分配的内存。
  - 当前活动
    - 状态寄存器。CPU状态CR0、指令指针IP
    - 通用寄存器。AX、BX。。。
  - 进程占用系统资源
    - 打开文件、已分配内存

因此即使是运行同一个程序代码两次，也是两个不同的进程。就像打开两个浏览器一样

**进程的特点**

- 动态性
  - 可动态地创建、结束进程
- 并发性
  - 进程可以被独立调度并占用处理机（CPU）运行
- 独立性
  - 不同进程的工作不相互影响
- 制约性
  - 因访问共享数据、资源或进程间同步而产生制约

**进程和程序的联系**

- 进程是OS处于执行状态程序的抽象
  - 程序=文件（静态的可执行文件）
  - 进程=执行的程序=程序+执行状态
- 同一个程序的多次执行过程对应为不同进程
  - 如命令ls的多次执行对应多个进程
- 进程执行所需要的资源
  - 内存：保存代码和数据
  - CPU：执行指令

**进程和程序的区别**

- 进程是动态的，程序是静态的
  - 程序是有序代码的集合
  - 进程是程序的执行，进程有核心态\用户态
- 进程是暂时的，程序是永久的
  - 进程是一个状态变化的过程
  - 程序可以长久保存
- 进程和程序的组成不同
  - 进程的组成包括程序、数据和PCB

## 进程控制块PCB

PCB：操作系统控制进程运行所用的信息集合

- 操作系统用PCB来描述进程的基本情况以及运行变化的过程
- PCB是进程存在的唯一标志。每个进程都在OS中有一个对应的PCB

进程控制块的**使用**

- 进程创建。生成该进程的PCB
- 进程终止。回收它的PCB
- 进程的组织管理。通过对PCB的组织管理来实现

进程控制块的**内容**

- 进程状态。创建、就绪、运行等
- 进程标识信息。进程编号，PID
- 程序计数器。进程要执行的下个指令的地址
- CPU寄存器。
  - 与计算机体系结构相关
  - 包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。
- CPU调度信息。进程优先级、调度队列的指针和其他调度参数
- 内存管理信息。OS所使用的内存系统，包括基址和界限寄存器的值、页表或段表
- 记账信息。CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等
- IO状态信息。包括分给进程的IO设备列表、打开的文件列表等

进程控制块的**组织**

- 链表
  - 同一状态的进程其PCB成一链表，多个状态对应多个不同的链表
    - 各状态的进程形成不同的链表：就绪链表、阻塞链表
- 索引表
  - 同一状态的进程归入一个索引表，由索引指向PCB

## 进程状态

进程生命周期划分

- 进程创建
  - 导致创建的事件
    - 系统初始化时
    - 用户请求创建一个新进程
    - 正在运行的进程执行了创建进程的系统调用
- 进程执行
  - 内核选择一个就绪的进程，让它占用处理机并执行
  - 依据CPU调度算法
- 进程等待
  - 进程进入等待（阻塞）的情况
    - 请求并等待系统服务，无法马上完成
    - 启动某种操作，无法马上完成
    - 需要的数据没有到达
  - 只有进程自身才能知道何时需要等待某种事件发生
    - 即是由进程本身内部原因引起的
- 进程抢占
  - 被抢占情况
    - 高优先级进程就绪
    - 进程执行当前时间用完
- 进程唤醒
  - 唤醒可能情况
    - 被阻塞进程需要的资源可被满足
    - 被阻塞进程等待的时间到达
  - 进程只能被别的进程或OS唤醒
- 进程结束
  - 结束可能情况
    - 正常退出（自愿）
    - 错误退出（自愿，进行了相应的处理保存）
    - 致命错误
    - 被其他进程杀死

进程切换

IO设备为定时器

![1551627626757](assets/1551627626757.png)

## 三状态进程模型

与CPU相关

进程状态

- 运行
  - 进程正在处理机上运行
- 就绪
  - 进程获得了除处理机以外所需的资源
- 等待状态 （阻塞）
  - 进程正在等待某一时间的出现而暂停运行
- 创建状态
  - 进程正在被创建，还没有赚到就绪状态之前的状态
  - 正在分配资源，已经相应数据结构完成初始化
- 结束
  - 进程正在从系统中消失的状态

状态变迁

![1551683110492](assets/1551683110492.png)

## 挂起进程模型

与存储相关

- 进程挂起：
  - 处于挂起状态的进程映像在磁盘上
  - 目的是减少进程占用内存
- 等待挂起状态
  - 进程在外存并等待事件的出现
- 就绪挂起状态
  - 进程在外存，但只要进入内存即可运行
    - 内存不够
    - 优先级不够高

状态转换

- 挂起：把一个进程从内存转到外存
  - 等待到等待挂起
    - 没有进程处于就绪状态或就绪进程要求更多的内存资源
  - 就绪到就绪挂起
    - 当有高优先级等待进程和低优先级就绪进程
  - 运行到挂起就绪
    - 对抢先式分时系统，当有高优先级等待挂起进程因时间出现而进入就绪
- 在外存时的状态转换
  - 等待挂起到就绪挂起
    - 当有等待挂起进程因相关事件出现
  - 激活：把一个进程从外存转到内存
    - 就绪挂起到就绪
      - 没有就绪进程或挂起就绪进程优先级高于就绪进程
    - 等待挂起到等待
      - 当一个进程释放足够内存，并有高优先级等待挂起进程

![1551684935696](assets/1551684935696.png)

状态队列

- 由操作系统维护一组队列，表示系统中所有进程的当前状态
- 不同队列表示不同状态
  - 就绪队列、等待队列等
- 根据进程状态不同，PCB加入相应队列
  - 进程状态变化时，PCB会换到另一个队列

# 线程

**为什么引入线程**

在一个进程当中希望有很好地并发性，多线程解决思路

- 在进程内部增加一类实体，满足一下特性
  - 实体之间可以并发执行
  - 实体之间共享相同的地址空间

## 线程的概念

线程是进程的一部分，描述指令流执行状。

- 它是**进程中的指令执行流（从进程中剥离）**的最小单元，是CPU调度的基本单位

- 进程的资源分配角色：进程由一组相关资源构成，包括地址空间，打开的文件等各种资源
- 线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态
- 线程控制块TCB

进程和线程的关系

![1551685825565](assets/1551685825565.png)

线程=进程-共享资源

- 线程的优点
  - 一个进程中可以同时存在多个线程
  - 各个线程间可以并发地执行
  - 各个线程间可以共享地址空间和文件等资源
- 线程的缺点
  - 一个线程崩溃，会导致其所属进程的所有线程崩溃

## 用户线程

线程的实现方式

- 用户线程：在用户空间实现
- 内核线程：在内核中实现
- 轻量级线程：在内核中实现，支持用户线程

用户线程：由一组用户级的线程库函数来完成线程的管理

![1551686435770](assets/1551686435770.png)

用户线程的特征

- 不依赖OS的内核
  - 内核不了解用户线程的存在
  - 可用于不支持线程的多进程操作系统
- 在用户空间实现的线程机制
  - 每个进程有私有的线程控制块列表
  - TCB由线程库函数维护
- 同一进程内的用户线程切换速度快
  - 无需用户态->核心态切换
- 允许每个进程拥有自己的线程调度算法

不足

- 线程发起系统调用而阻塞，则整个进程进入等待
- 不支持基于线程的处理机抢占
  - 除非当前允许线程主动放弃，它所在进程的其他线程无法抢占CPU
- 线程只能按进程分配CPU时间
  - 多个线程进程中，每个线程的时间片较少

## 内核线程

由内核通过系统调用实现的线程机制，由内核来完成线程的创建、终止、管理

![1551686676855](assets/1551686676855.png)

内核线程的特征

- 由内核维护PCB和TCB
- 线程执行系统调用而被阻塞不影响其他线程
- 线程的创建终止、切换开销相对较大
  - 通过系统调用/内核函数，在内核中实现
  - 要先由用户态转到内核态
- 以线程为单位进行CPU时间分配
  - 多线程进程可以获得更多CPU时间

## 轻权进程

内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。

内核线程与用户线程的结合，过于复杂，没体现优势

# 进程与线程区别

## 进程与线程的比较

- 进程是资源分配的单位，线程是CPU调度单位
- 进程拥有一个完整的资源平台，线程只独享指令流执行的必要资源，如寄存器和栈
- 线程具有就绪、等待和运行三种基本状态和状态间的转换关系
- 线程能减少并发执行的时间和空间开销
  - 线程的创建时间比进程短
  - 线程的终止时间比进程短
  - 同一进程内的线程切换时间比进程短
  - 由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信

# 进程调度

进程调度选择一个可用的进程到CPU上执行。

**调度队列**

进程进入系统时，会被加到作业队列中，队列中包括系统中的所有进程。

队列通常使用链表来实现，头指针指向链表的第一个和最后一个PCB块的指针，每个PCB包括一个指向就绪队列的下一个PCB的指针域

## 上下文切换

进程上下文由进程PCB表示

- 包括CPU寄存器的值、进程状态、内存管理信息等。

**上下文切换**：将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程状态，这一个任务称为上下文切换。

- 速度依赖于内存速度、必须复制的寄存器数量、是否有特殊指令（如装入或保存所有寄存器的单个指令）
- 与硬件支持相关。有的处理器提供了多组寄存器集合，只需要简单地改变当前寄存器组的指针即可。

# 进程控制

## 进程切换

定义

- 暂停当前运行进程，从运行状态变成其他状态
- 调度另一个进程从就绪状态变成运行状态

进程切换的要求

- 切换前，保存进程上下文
- 切换后，恢复进程上下文
- 快速切换

进程生命周期的信息

- 寄存器 PC SP
- CPU状态
- 内存地址空间

PCB：内核的进程状态记录

- 内核为每个进程维护了相应的进程控制块
- 内核将相同状态的进程的PCB放置在同一队列

## 进程创建

fork复制原有进程

exec进行重写

## 进程加载

用户的应用程序通过系统调用加载来完成一个新的可执行文件的加载

## 进程等待与退出

父子进程的一种交互

wait()系统调用用于父进程等待子进程的结束

- 子进程结束时，通过exit向父进程返回一个值
- 父进程通过wait接受并处理返回值

wait系统调用的功能

- 有子进程存活时，父进程进入等待状态，等待子进程的返回结果
  - 当某子进程调用exit时，唤醒父进程，将exit的返回值作为副进程中wait的返回值
- 有僵尸子进程等待时，wait立即返回其中一个值
- 无子进程存活，wait立刻返回

进程的有序终止exit

- 进程结束执行时调用exit，完成进程资源回收
- exit系统调用的功能
  - 将调用参数作为进程的结果
  - 关闭所有打开的文件等占用资源
  - 释放内存
  - 释放大部分进程相关的内核数据结构
  - 检查释放父进程是存活着的
    - 如存活，保留结果的值直到父进程需要它，进入僵尸状态
    - 如果没有，释放所有数据结构，进程结束
  - 清理所有等待的僵尸进程
- 进程终止是最终的垃圾回收（资源回收）

## 其他进程控制系统调用

- 优先级控制
- 进程调试支持
  - 允许一个进程控制另一个进程的执行
  - 设置断点和查看寄存器
- 定时
  - sleep



# 参考 #

1. 

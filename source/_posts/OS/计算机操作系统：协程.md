---
title: 计算机操作系统：协程
type: tags
tags:
  - 操作系统
date: 2019-03-22 15:00:11
categories: OS
description: 
---

# 协程

## 生产者消费者模式

1.定义了一个生产者类，一个消费者类。

2.生产者类循环100次，向同步队列当中插入数据。

3.消费者循环监听同步队列，当队列有数据时拉取数据。

4.如果队列满了（达到5个元素），生产者阻塞。

5.如果队列空了，消费者阻塞。

该生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：

1.涉及到同步锁。

2.涉及到线程阻塞状态和可运行状态之间的切换。

3.涉及到线程上下文的切换。

以上涉及到的任何一点，都是非常耗费性能的操作。

## **什么是协程**

**协程，英文Coroutines，是一种比线程更加轻量级的存在。**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

- 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。
  - 所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。
  - 子程序调用总是一个入口，一次返回，调用顺序是明确的。
- 而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
  - 但是子程序之间不相互调用，而是类似线程，在并行执行

![img](assets/1529501501760106.jpg)



最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

### 使用

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

- 子例程（函数）的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次。
- 协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。子例程的生命期遵循后进先出（最后一个被调用的子例程最先返回）；相反，协程的生命期完全由他们的使用的需要决定。

由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），所以我们来看一看python当中对协程的实现案例，同样以生产者消费者模式为例：

![img](assets/1529501501404928.png)



这段代码十分简单，即使没用过python的小伙伴应该也能基本看懂。

代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。

其中 **yield** 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。

### 优势

- 协程的开销远远小于线程的开销。
  - yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。
- 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

# 参考 #

1. 

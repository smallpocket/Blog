---
title: 计算机操作系统（7）：同步互斥
type: tags
tags:
  - null
date: 2019-03-05 17:53:03
categories:
description:
---

# 同步互斥

同步互斥是OS当中协调进程之间动作和相互关系之间的机制。

# 背景

并发基础的正确性

- 独立进程
  - 不和其他进程共享资源或状态
  - 确定性：输入状态决定结果
  - 可重现：能够重现其实条件
  - 调度顺序不重要
- 并发进程
  - 在多个进程间有资源共享
  - 不确定性
  - 不可重现
- 并发进程的正确性
  - 执行过程是不确定性和不可重现的
  - 程序错误可能是间歇性发生的

进程并发执行的好处

- 进程需要与计算机中的其他进程和设备进行协作
- 好处1：共享资源
  - 多个用户使用同一台计算机
  - 银行账户存款余额在多ATM上操作
- 好处2：加速
  - IO操作与CPU计算并行
  - 程序可以划分为多个模块放在多个处理器上并行执行
- 好处3：模块化
  - 将大程序分解为小程序
  - 使系统易于复用与扩展

并发创建新进程时的标识分配

- 程序可以调用函数fork来创建一个新的进程
  - 操作系统需要分配一个新的并且唯一的进程PID
  - new_pid=next_pid++;
    - 读取值
    - 写入值
    - 即不是原子操作
    - ![1551865407070](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551865407070.png)

## **原子操作**

- 原子操作时指一次不存在任何中断或失败的操作
  - 要么操作成功执行
  - 要么操作没有执行
  - 不会出现部分执行的状态
- 操作系统需要利用同步机制在并发执行的同时，保证一些操作时原子操作

# 现实生活的同步问题

进程间的交互关系：相互感知程度

![1551866855340](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551866855340.png)

三种关系：

- 互斥
  - 一个进程占用资源，其他进程不能使用
- 死锁
  - 多个进程各自占用部分资源，形成循环等待
- 饥饿
  - 其他进程可能轮流占用资源，一个进程一直得不到资源

# 临界区

临界区：进程中访问临界资源的一端需要互斥执行的代码

进入区：

- 检查可否进入临界区的一段代码
- 如可进入，则设置正在访问临界区标志

退出区：清除正在访问临界区标志

**临界区的访问规则**

- 空闲则入
  - 没有进程在临界区时，任何进程可进入
- 忙则等待
  - 与进程在临界区时，则其他进程均不能进入临界区
- 有限等待
  - 等待进入临界区的进程不能无限制等待
- 让权等待
  - 不能进入临界区的进程，应当释放CPU

不同临界区实现机制的比较

- 性能：并发级别

## 禁用硬件中断的同步方法

- 没有中断，没有上下文切换，因此没有切换
  - 硬件将中断处理延迟到中断被启用之后
  - 现代OS都提供指令来实现禁用中断
- 进入临界区
  - 禁止所有中断，并保存标志
- 退出临界区
  - 使能中断

**缺点**

- 禁用中断后，进程无法被停止
  - 整个系统都会为此停下来
  - 可能导致其他进程处于饥饿状态
- 临界区可能很长
  - 无法确定响应中断所需的时间
- 要小心使用，只在不用的时候才用

## 基于软件的同步方法

在两个进程间，通过对共享变量的访问实现同步

![1551883847062](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551883847062.png)

### Peterson算法

- 满足线程T0与T1之间互斥的经典的基于软件的解决方案
- 共享变量
  - ![1551884119551](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884119551.png)
- 进入区代码
  - ![1551884131451](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884131451.png)
  - turn=，是写操作，是原子性的
- 退出区代码
  - flag[i]=false

基于软件的解决方法分析

- 复杂
  - 需要两个进程间共享数据
- 需要忙等待
  - 浪费CPU时间

## 高级抽象的同步方法

基于硬件的同步原语

- 硬件提供了一些同步原语
  - 中断禁用、原子操作指令等
- 操作系统提供更高级的编程抽象来简化进程同步
  - 锁、信号量等
  - 使用硬件原语来构建
  - 简化进程同步

### 锁

锁是一个抽象的数据结构

- 一个二进制变量（锁定、解锁）
- Lock::Acquire()
  - 锁被释放前一直等待，然后得到锁
- Lock::Release
  - 释放锁，唤醒任何等待的进程

### **原子操作指令**

- 现代CPU体系结构当中都提供一些特殊的原子操作指令
  - 这些指令将若干个操作合成一个原子操作
- 测试和置位（Test and Set）TS指令
  - 从内存单元中读取值
  - 测试该值是否为1（然后返回真或假）
  - 内存单元设置为1
  - ![1551884687997](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884687997.png)
- 交换指令
  - 交换内存中的两个值
  - ![1551884710140](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884710140.png)

**使用TS指令实现自旋锁**

![1551884818239](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884818239.png)

线程在等待的时候消耗CPU时间

**无忙等待锁**

增加一个等待队列

![1551884886453](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551884886453.png)

原子操作指令锁的**特征**

- 优点
  - 适用于单处理器或者共享主存的多处理器中任意数量的进程同步
  - 简单且容易证明
  - 支持多临界区
- 缺点
  - 忙等待消耗CPU时间
  - 可能导致饥饿
    - 进程离开临界区时有多个等待进程的情况
  - 死锁
    - 用于临界区的低优先级进程
    - 请求访问临界区的高优先级进程获得处理器并等待临界区

## 同步方法总结

- 锁是一种高级的同步抽象方法
  - 互斥可以使用锁来实现
  - 需要硬件支持
- 常用的三种同步实现方法
  - 禁用中断。仅限于单处理器
  - 软件。复杂
  - 原子操作指令。使用最多，容易验证。

# 信号量

- 信号量是操作系统提供的一种协调共享资源访问的方法
  - 软件同步是平等线程间的一种同步协商机制
  - OS是管理者，地位高于进程，即一个仲裁者
  - 用信号量表示系统资源的数量
- 早期的操作系统的主要同步机制

信号量

- 是一种抽象数据结构
  - 由一个整数变量sem和两个原子操作组成
  - P操作
    - sem-1
    - 如sem<0，进入等待，否则在继续
  - V操作
    - sem+1
    - 如sem<=0，唤醒一个等待进程
- 是被保护的整数变量
  - 初始化完成后，只能通过P和V操作修改
  - 由操作系统保证，PV操作是原子操作
    - OS高于进程，是管理者，不会受到进程干扰
- P可能阻塞，V不会阻塞
- 通常假定信号量是个屁的
  - 线程不会被无限期阻塞在P操作
  - 假定信号量等待按先进先出排队

实现

![1551940418870](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551940418870.png)

信号量分类

- 二进制信号量：资源数目为0或1
- 资源信号量：资源数目为任何非负值
- 两者等价
  - 基于一个可以实现另一个

## 信号量的使用

- 互斥访问
  - 临界区的互斥访问控制
- 条件同步
  - 线程间的事件等待

**互斥访问**

每类资源设置一个信号量，其初值为1.

- 必须成对使用P操作与V操作

**条件同步**

条件同步设置一个信号量，其初值为0

一个线程进行V操作，一个线程进行P操作实现同步协作。

**信号量的困难**

- 读/开发代码比较困难
- 容易出错
  - 使用的信号量已经被另一个线程占用等
- 不能处理死锁问题，在写程序中解决

# 管程

改进信号量在处理临界区的一些麻烦，解决PV操作的配对

- 管程是一种用于多线程互斥访问共享资源的程序结果
  - 采用面向对象方法，简化了线程间的同步控制
  - 任一时刻最多只有一个线程执行管程代码
  - 正在管程中的线程可以临时放弃管程的互斥访问，等待事件出现时恢复。
    - 一个赛道上，只有一辆赛车可以跑，赛车加燃料期间，可以让另一辆车进场
- 管程的使用
  - 在对象/模块中，收集相关共享数据
  - 定义访问共享数据的方法
- 管程的组成
  - 一个锁
    - 控制管程代码的互斥访问
  - 0或多个条件变量
    - 管理共享数据的并发访问
  - 条件变量：
    - 是管程内的等待机制
    - 进入管程的线程因资源被占用而进入等待状态
    - 每个条件变量表示一种等待原因，对应一个等待队列
  - wait操作
    - 将自己阻塞在等待队列中
    - 唤醒一个等待者或释放管程的互斥访问
  - signal操作
    - 将等待队列中的一个县城唤醒
    - 如果等待队列为空，则等于空操作
  - ![1551943339583](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551943339583.png)

两种不同的管程

真实系统中常用hansen管程（当前执行的管程更具有优先权，要在当前执行管程放弃使用权后，才转移），少一次切换。

Hoare管程行为确定性更好

![1551943635198](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551943635198.png)

# 生产者消费者问题

有界缓冲区的生产者-消费者问题

- 一个或多个生产者在生成数据后放在一个缓冲区里
- 单个消费者从缓冲区取出数据处理
- 任何时刻只能有一个生产者或消费者进入缓冲区

问题分析

- 任何时刻只能有一个线程操作缓冲区 ： 互斥访问
- 缓冲区空时，消费者必须等待生产者 ： 条件同步
- 缓冲区满时，生产者必须等待消费者 ： 条件同步

![1551940987820](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551940987820.png)

## 哲学家就餐问题

问题描述：

- 5个哲学家围绕一张圆桌而坐
  - 桌子上放着5支叉子
  - 每两个哲学家之间放一支
- 哲学家的动作包括思考和进餐
  - 进餐时需同时拿到左右两边的叉子
  - 思考时将两支叉子放回原处

**信号量**

偶数号先右后左，奇数先左后右，因此不会构成环路

![1551945115548](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551945115548.png)

## 读者-写者问题

问题描述：

- 共享数据的两类使用者
  - 读者：只读取数据，不修改
  - 写者：读取和修改数据
- 问题描述：对共享数据的读-写
  - 读 - 读 允许
    - 同一时刻运行有多个读者同时读
  - 读-写 互斥
    - 没有写者时读者才能读
    - 没有读者时，写者才能写
  - 写-写 互斥

**信号量**

- 用信号量描述每个约束
  - 信号量WriteMutex
    - 控制读写操作的互斥
    - 初始化为1
  - 读者计数Rcount
    - 正在进行读操作的读者数目
  - 信号量CountMutex
    - 控制对读者计数的互斥修改
    - 初始为1

![1551945496464](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1551945496464.png)



# 参考 #

1. 

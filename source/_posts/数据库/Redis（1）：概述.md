---
title: Redis（1）：概述
type: tags
tags:
  - NoSQL
  - Redis
date: 2019-03-04 17:11:51
categories: 数据库
description:
---

# 数据结构与对象

Redis数据库里面的每个键值对都是由对象组成的

- 数据库键总是一个字符串对象
- 数据库键的值可以是
  - 字符串对象
  - 列表对象
  - 哈希对象
  - 集合对象（set）
  - 有序集合对象

# 单机数据库的实现

- 数据库
  - Redis数据库的实现原理
  - 说明了服务器保存键值对的方法
  - 服务器保存键值对过期时间的方法
  - 服务器自动删除过期键值对的方法
- RDB持久化、AOF持久化
  - Redis两种持久化方法的实现原理
  - 服务器根据数据库来生成持久化文件的方法
  - 服务器根据持久化文件还原数据库的方法
  - BGSAVE与BGREWAITEAOF的实现原理
- 事件
  - 文件事件
    - 应答客户端连接请求
    - 接收客户端发送的命令请求
    - 向客户端返回命令回复
  - 时间事件
    - 执行redis.c/serverCron函数，通过执行常规的维护和管理操作保持Redis服务器的正常运作
    - 触发一些定时操作
- 客户端
- 服务器

# 缓存使用

如何利用有限的资源提供尽可能大的吞吐量

请求直接从缓存中获取数据，直接返回

**缓存特征**

- 命中率：命中数/（命中数+没有命中数）
  - 没有命中，缓存过期，需要从数据库当中重新获取
  - 影响因素
    - 业务场景和业务需求：读多写少，实时性要求越低
    - 缓存的设计（粒度和策略）：粒度越小，命中率越高。如果缓存一个对象与一个组的对象，一个对象的命中率更高。缓存策略，即缓存的更新。
    - 缓存容量和基础设施：多数采用LRU算法。
    - 并发越高，即使过期时间很短，缓存收益也很高
    - 当缓存结点出现故障，需要避免缓存失效，并最大程度降低影响
- 最大元素（空间）：缓存中可以存放的最大数量
- 清空策略：FIFO、LFU、LRU，过期时间、随机等

**缓存分类和应用场景**

根据缓存与应用的耦合度

- 本地缓存
  - 编程实现，成员变量、局部变量、静态变量、Guava Cache
  - 无法共享
- 分布式缓存
  - Memcache、Redis

# Guava Cache

# Redis

![1552978943031](assets\1552978943031.png)

Redis所有操作都是原子性的。

使用场景

# 高并发场景下缓存常见问题

- 缓存一致性
  - 当数据时效要求很高，要保证缓存中的数据与数据库中的数据保持一致。并且缓存结点与副本中的数据也保持一致。
  - 依赖缓存的过期与更新策略。在数据发生更改时，主动更改缓存中的数据，或移除对应的缓存
    - 更新数据库成功，更新缓存失败，数据不一致
    - 更新缓存成功，更新数据库失败，数据不一致
    - 更新数据库成功，淘汰缓存失败，数据不一致
    - 淘汰缓存成功，更新数据库失败，查询缓存miss
- 缓存并发问题
  - 缓存过期后，将尝试从后端数据库获取数据。在高并发下，可能多个请求同时向数据库请求获取
  - ![1552980709600](assets\1552980709600.png)
- 缓存穿透问题
  - 某个key在高并发的访问下没有被命中，出于容错率的情况，尝试去后端数据库中获取，导致大量的请求到达数据库本身。当该key对应的数据本身为空，就会导致数据库中并发执行很多不必要的操作
  - 缓存空对象，对查询结果为空的对象也进行缓存
- 缓存的雪崩现象
  - 缓存抖动（颠簸），缓存结点故障，通过一致性哈希算法解决
  - 由于缓存的原因，导致大量请求到达后端数据库，导致数据库崩溃，系统崩溃。
  - 可能由于缓存抖动、缓存并发、或者部分缓存集体失效过期导致
  - 通过限流、降级、熔断手段降低影响，通过多级缓存

# 参考 #

1. 

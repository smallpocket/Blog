---
title: Redis（3）：单机数据库的实现
type: tags
tags:
  - null
date: 2019-03-04 18:37:09
categories:
description:
---

# 数据库

- Redis服务器的数据库实现
  - 服务器保存数据库的方法
  - 客户端切换数据库的方法
  - 数据库保存键值对的方法
  - 数据库的增删改查的实现方法
  - 服务器保存键的过期时间的方法
  - 服务器自动删除过期键的方法
  - Redis2.8数据库通知功能的实现

## 服务器中的数据库

Redis服务器奖所有数据库保存在服务器状态中

```C
struct redisServer{
    //一个数组，保存着服务器中所有的数据库
    redisDb *db;
    //服务器中的数据库数量
    int dbnum;
}
```



## 切换数据库

每个redis客户端都有自己的目标数据库，即写命令的操作对象，默认为0号数据库

执行select 2（需要转换到的数据库，即db[2]）命令可切换目标数据库

```
typedef struct redisClient;{
    //记录客户端当前使用的数据库
    redisDb *db;
}redisClient;
```

## 数据库键空间

Redis是一个键值对数据库服务器，服务器每一个数据库都是由一个redisDb表示

```
typedef struct redisDb{
    //数据库键空间，保存着数据库中所有的键值对
    dict *dict;
}redisDb;
```

键空间与用户所见的数据库是直接对应的。键空间的键就是数据库的键，键空间的值就是数据库的值

**添加新键**

```sql
set date "222"
```

**删除键**

```sql
del date
```

**更新键**

```sql
set date "balst"
```

**取值**

```sql
get date
```

等命令

**读写键空间的维护操作**

当使用Redis命令对数据库进行读写，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作

- 读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或不明智次数
- 读取一个键后，服务器会更新键LRU时间，用于计算键的闲置时间
- 服务器在读取一个键时发现该键已经过期，服务器会先删除这个过期键，然后才执行余下的其他操作
- 如果有客户端使用Watch监视了某个键，服务器在对该键进行修改后，会将这个键标记为脏，从而让事务注意到这个键已经被修改
- 服务器每次修改一个键后，都会对脏键计数器++，这个计数器会触发服务器的持久化以及复制操作
- 如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送给相应的数据库通知

## 设置键的生存时间或过期时间

使用EXPIRE命令或者PEXPIRE，以毫秒或秒的精度为数据库的某个键设置生存时间。在经过指定的时间，服务器会自动删除生存时间为0的键。

以Expireat或PExpireat为键设置过期时间，当过期时间来临，自动删除该键。

**保存过期时间**

redisDb结构中的expires字典保存了数据库中所有键的过期时间，称为过期字典

```C
dict *expires;//值是long long类型的整数，保存这个键指向的数据库键的过期时间
```

## 过期键删除策略

如果一个键过期了，那么它什么时候会被删除呢

- 定时删除
  - 在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作
- 惰性删除
  - 放任键过期不管，每次从键空间获取键时，都检查获得的键是否过期
- 定期删除
  - 每隔一段时间，就对数据库进行一次检查，删除里面的过期键。删除的数量以及检查多少数据库由算法决定

## Redis的过期键删除策略

采用惰性删除与定期删除两种策略

## AOF、RDB和复制功能对过期键的处理

过期键对Redis服务器中其他模块的影响

**生成RDB文件**

SAVE命令或BGSAVE命令创建一个新的RDB文件时，已过期的键不会被保存到新创建的RDB文件中

**载入RDB文件**

在启动Redis服务器，如果开启了RDB功能，服务器会对RDB文件载入

- 如果服务器以主服务器模式允许，那么载入RDB文件时，过期键将会忽略
- 如果以从服务器允许，文件中所有键，不管是否过期，都会载入到数据库中。
  - 主从服务器进行数据同步时，从服务器的数据库就会被清空，因此过期键对从服务器也不会造成影响

**AOF文件写入**

当服务器以AOF持久化模式运行时，如果键已经过期，但没有删除，那么AOF文件不会因为这个过期键产生任何影响。

当过期键被删除后，程序会向AOF文件追加DEL命令，以显式记录该键已经被删除。

**AOF重写**

已过期的键不会被保存到重写后的AOF文件中

**复制**

当服务器允许在复制模式下，从服务器的过期键删除动作由主服务器控制

- 主服务器在删除一个过期键后，会显式向所有从服务器发送一个DEL命令
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是继续像处理未过期键一样处理
- 从服务器只有在接到主服务器的DEL命令才会删除过期键

## 数据库通知

Redis2.8，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况

# RDB持久化

Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，每个非空数据库又可以包含任意个键值对。

数据库状态：服务器中的非空数据库以及它们的键值对。

Redis是内存数据库，将数据库状态存储在内存当中，如果服务器进程一旦退出，则数据库状态也会消失不见。

因此提供了RDB持久化功能，**将Redis在内存当中的数据库状态保存到磁盘当中**。

- RDB持久化既可以手动，也可以根据服务器配置定期执行。将某个时间点上的数据库状态保存到一个RDB文件中
- RDB持久化功能生成的RDB文件是一个压缩的二进制文件。

## RDB文件的创建于载入

- 生成命令：SAVE于BGSAVE
  - SAVE会阻塞Redis服务器进程，直到RDB文件创建完毕为止
  - BGSAVE会派生一个子进程，子进程负责创建RDB文件，服务器进程继续处理命令

RDB文件的载入时在服务器启动时自动执行，只要检测到RDB文件，就会自动载入。在载入文件期间，服务器一直处于阻塞状态。

与AOF对比

- AOF文件的更新频率通常比RDB文件更新频率高，因此
- 如果服务器开启了AOF持久化功能，服务器会优先使用AOF文件来还原数据库状态
- 只有在AOF持久化功能处于关闭状态，服务器才会使用RDB文件来还原数据库状态

## 自动间隔保存

Redis允许用户通过服务器配置save选项，让服务器每隔一段时间自动执行一次BGSAVE

## RDB文件结构

结构：

![1552468398778](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552468398778.png)

- RDB文件保存的是二进制数据，而不是C字符串
- REDIS：长度为5字节，通过检测该字符，快速检查所载入的文件是否为RDB文件
- db_version：4字节，是一个字符串表示的整数，记录了RDB文件版本号
- database：包含0或任意个数据库，以及各个数据库中的键值对数据
- EOF：长度为1字节，表示正文内容结束
- check_sum：一个8字节长的无符号整数，保存一个校验和，通过对前4部分计算得出。服务器载入RDB文件时，会将载入数据计算得出的校验和与check_sum进行比较，以检查文件是否出错或损坏

**database部分**

如果0号与3号数据库非空，则：

![1552468706260](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552468706260.png)

每个非空数据库在RDB文件中的保存：

![1552468722522](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552468722522.png)

- SELECTDB：长度为1字节，表示接下来读取的是一个数据库号码
- db_number：保存着一个数据库号码，长度1、2、5字节，当读取到的时候，服务器使用select进行数据库切换
- key_value_pairs保存所有键值对数据

**key_value_pairs**

如果键值对带有过期时间，则也会保存在内。不带过期时间的表示：

![1552468871546](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552468871546.png)

![1552468919035](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552468919035.png)

- TYPE：对象类型或者底层编码，决定如何读入和解释value数据
- key：字符串对象
- EXPIRETIME_MS：1字节，表示接下来将读取一个过期时间，以毫秒为单位
- ms：8字节带符号整数，记录一个毫秒为单位的UNIX时间戳

**value的编码**

不同类型的值对象在RDB文件中的保存结构

字符串对象

列表对象

集合对象

哈希表对象

有序集合对象

## 分析RDB文件

# AOF持久化

通过保存Redis服务器所执行的写命令来记录数据库状态

![1552469157583](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552469157583.png)

写入的命令都是以Redis的命令请求协议格式保存的。

## AOF持久化的实现

功能实现分为：命令追加、文件写入、文件同步三个步骤

**命令追加**

当服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾

**文件写入与同步**

- 文件写入：只是写入到了内存缓冲区，可能还没有写到文件所拥有的磁盘数据块上 
- 文件同步：将缓冲区中的内容冲洗到磁盘上

Redis服务器进程就是一个事件循环，在循环中的

- 文件事件负责接收客户端的命令请求，以及向客户端发送命令恢复
- 时间事件负责执行像serverCron函数这样需要定时运行的函数

服务器在处理文件事件时可能执行写命令，使得一些内容被追加到aof_buf缓冲区，因此服务器每次结束一个事件循环前，都会调用函数，考虑是否将aof_buf缓冲区里的内容写入和保存到AOF文件中。

![1552470569474](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552470569474.png)

flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值决定

- 值为always，将缓冲区内所有内容写入并同步到AOF文件
- 默认为everysec，将缓冲区内所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1S，则再次对AOF文件进行同步
- no，将缓冲区内所有内容写入并同步到AOF文件，但并不进行同步，何时同步由操作系统决定

## AOF文件载入与数据还原

![1552470819774](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552470819774.png)

## AOF重写

随着服务器允许，AOF文件内容与体积会越来越大，可能会对服务器造成影响，并且文件太大会使得AOF文件进行数据还原时间太长。

AOF文件重写：创建一个新的AOF文件替代现有的AOF文件，新旧的AOF保存的数据库状态相同，但是新的AOF文件不包含任何浪费空间的冗余指令。

冗余指令：

![1552470946418](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552470946418.png)

**AOF文件重写的实现**

通过读取服务器当前数据的状态来实现

**AOF后台重写**

因为Redis使用单个线程处理命令请求，如果由服务器调用重写，则会无法处理客户端命令请求

使用子进程进行重写。

- 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免在使用锁的情况下，保证数据的安全性
- 在AOF重写期间，可能会出现对现有数据库状态的修改
  - 设置AOF重写缓冲区，当Redis执行完一个写命令，会将命令同时发送给AOF缓冲区与AOF重写缓冲区
  - 当子进程完成AOF后，向父进程发送信号，将AOF重写缓冲区所有内容写入新AOF文件
  - 替换原有的AOF文件

# 事件

Redis服务器是一个事件驱动程序，需要处理一下两类事件

- 文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列的网络通信操作
- 时间事件：需要在给定的时间点执行的操作

# 客户端

Redis服务器是典型的一对多服务器程序：一个程序可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。

通过使用由IO多路复用技术实现的文件事件处理器，Redis使用单线程单进程处理命令，并与多个客户端进行网络通信

# 服务器



# 参考 #

1. 

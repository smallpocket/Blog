---
title: 策略模式
type: tags
tags:
  - null
date: 2018-10-09 09:04:04
categories:
description: 设计模式入门学习，涉及到：策略模式
---
# 策略模式

## 工具

### OO基础

1. 抽象
2. 封装
3. 多态
4. 继承

### OOO原则

1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，不针对实现编程

#### 封装变化

>找出应用中可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混合在一起
- 把会变化的部分取出来并"封装"起来,好让其他部分不会受到影响
- 即,如果每次新的需求到来,都会使得某方面的代码发生变化, 即确定,该部分的代码需要被抽取出来

#### 针对接口编程，不针对实现编程

> 针对接口编程,而不是针对实现编程
- 该设计原则关注于类的扩展性
- 面对一个可能存在变化的类,将其变化抽出来制作一个接口,并针对接口进行不同的实现,从而使得类在"运行时"动态地"改变"
- 这个抽离的接口可以被复用，因为他们的行为已经和原来的类没有了关系
- 通过如此设计，我们可以新增行为，不会影响到既有的行为类，也不会影响“使用”到该行为的类
- 关键在于，现在这样的行为是委托给别人处理，而不是使用定义在父类或者子类内的方法

#### 多用组合，少用继承

### OO模式

策略模式：定义了算法族，分别分装起来，让他们可以互相替换，此模式使得算法的变化独立于使用算法的客户

## 介绍

策略模式定义了算法族，分别分装起来，让他们可以互相替换，此模式使得算法的变化独立于使用算法的客户

# 情景举例

存在一个种群：鸭子  
有些鸭子会飞、有些不会、有些快、有些慢，但都是在飞，那么考虑两种实现方法。
- 使用继承，在每一个子类进行重写。
- 创建一个飞行接口，然后交由一组类进行实现该接口。这样就可以使得鸭子实现复用

# 实现

## 父类Duck

可以看到在父类当中，我们定义了一个接口，但是没有任何的引用对象。  
同样也定义了一个方法，但是没有具体的内容，在子类中，需要对它进行@Override重写

``` java
/**
 * @Author : Hyper
 * @Time : 2018/10/8 19:17
 */
public abstract class Duck {
    /**
     * 声明两个行为为接口类型
     * 每一个鸭子都会引用实现该接口的对象
     */
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    /**
     * 这些行为不是由Duck本身进行实现的,而是转交给了对应的接口引用的对象
     */
    public void performQuack() {
        quackBehavior.quack();
    }

    public void performFly() {
        flyBehavior.fly();
    }

    /**
     * 动态地设定鸭子的行为
     *
     * @param fb
     */
    public void setFlyBehavior(FlyBehavior fb) {
        this.flyBehavior = fb;
    }

    public void setQuackBehavior(QuackBehavior qb) {
        this.quackBehavior = qb;
    }

    /**
     * 较差的方法:呱呱叫
     * 需要通过继承@Override重写
     */
    public void quack() {
    }

    /**
     * 游泳
     */
    public void swim() {
    }

}
```

## 实现飞行行为

首先，为了多态，先定义了一个飞行行为的接口，可以看到，在该接口当中，我们定义了一个fly()的方法。
``` java
/**
 * 抽离飞行的动作,制作接口
 */
public interface FlyBehavior {
    void fly();
}
```
接下来，对该接口进行实现
``` java
/**
 * 实现飞行的动作
 *
 * @Author : Hyper
 * @Time : 2018/10/8 19:41
 */
public class FlyWithWings implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println("FlyWithWings.class");
    }
}
```
另一个实现
````java
/**
 * 火箭动力
 */
public class FlyRocketPowered implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println("FlyRocketPowered.class");
    }
}
````
这样一来，我们还可以看到所有的飞行行为，同时如果有需求的变化，我们可以在一个实现里面修改

## 子类

``` java
/**
 * 整合接口的实例变量到具体的Duck中
 */
public class MarrardDuck extends Duck {

    /**
     * 在实例化的时候更改接口的对象,使得所有的对象都是这样的一个引用对象
     * 在该类使用飞行的时候,就会调用FlyWithWings的对象
     * 因为它引用的对象是FlyWithWings的实体
     */
    public MarrardDuck() {
        flyBehavior = new FlyWithWings();
        quackBehavior = new Quack();
    }
}
```
在该子类当中，我们将超类的接口，引用到了一个实例。

## 测试

做一个简单的测试
```java
public class Main {
    /**
     * @param args
     */
    public static void main(String[] args) {
        Duck duck = new MarrardDuck();
        duck.performFly();
        duck.performQuack();
    }
}
```
输出结果为：
```java
FlyWithWings.class
Quack.class
```
即接口引用到了该子类真正的飞行方法。

## 动态更改

在父类当中，设置了一个方法setFlyBehavior(FlyBehavior fb)，该方法实现动态化

应用到子类当中

```java
public class ModuleDuck extends Duck {
    public ModuleDuck() {
        flyBehavior = new FlyWithWings();
        quackBehavior = new Quack();
    }
}
```
进行一次测试
```java
public class MiniDuckSimulator {
    public static void main(String[] args) {
        Duck duck = new ModuleDuck();
        duck.performQuack();
        duck.performFly();
        //升级这鸭子,让他来点花样飞行
        duck.setFlyBehavior(new FlyRocketPowered());
        //它变强了
        duck.performFly();
    }
}
```
输出结果为：
```java
Quack.class
FlyWithWings.class
FlyRocketPowered.class
```
即方法动态的更改

# 参考 #
1. 

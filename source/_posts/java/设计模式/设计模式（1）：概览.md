---
title: 设计模式简单概览
type: tags
tags:
  - 设计模式
date: 2018-10-08 17:03:13
categories: Java
description: Java设计模式的学习
---
# 设计模式介绍

- 设计模式是构造OO系统的隐含经验，是为了设计出弹性的、可复用的、可维护的系统
- 建立可维护的系统，在于随时思考系统之后可能需要的变化以及应付变化的原则
- 当找不到合适的设计模式，则思考一下面向对象的原则，例如：抽象、封装这些很基础的东西

常用设计模式：

- 单例模式
- 策略模式
- 代理模式
- 观察者模式
- 装饰模式
- 适配器模式
- 命令模式
- 工厂模式
- 模板方法模式
- 建造者模式

## 模式的重要性

- 知道OO基础，并不足以设计出良好的OO系统
- 良好的OO设计必须具备可复用、可维护、可扩充的特性
- 模式可以让我们建造出具有良好的OO设计质量的系统
- 模式可以认为是历经验证的OO设计经验
- 模式不是代码，而是针对设计问题的通用解决方案，可把他们应用到特定的应用中
- 大多数的模式和原则，都着眼于软件变化的主题
- 大多数模式都允许系统局部改变独立于其他部分

# 设计模式类目

## 创建型

### 工厂模式

> 定义：定义一个创造对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

## 

### 单例模式

> 定义：确保一个类只有一个实例，并提供全局访问

## 

### 建造模式

### 原型模式

## 行为型

### 命令模式

> 定义：将请求封装成对象，这可以让你使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也支持撤销操作

### 迭代器模式

> 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

### 观察者模式

> 定义：在对象间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新

### 策略模式

> 定义：定义了算法族，分别分装起来，让他们可以互相替换，此模式使得算法的变化独立于使用算法的客户

为多种算法创建一个统一的接口，客户持有一个接口引用，可以自由地切换算法类。

例：一个人自由切换它的出行方式（自行车、汽车）。因此就不需要去使用IF判断他的出行方式而在客户类当中书写相应代码。

### 状态模式

> 定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类

### 模板方法模式

> 定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

## 结构型

### 适配器模式

> 适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间

### 外观模式

> 外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

### 代理模式

> 定义：为另一个对象提供一个替身或者占位符以访问这个对象。

### 装饰者模式

> 定义：动态地将责任附加到对象上，想要扩展功能，装饰者提供有别于继承的另一种选择





## 

### 组合模式

> 组合模式：允许你将对象组成树形结构来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象和对象组合

## 





## 复合模式

> 定义：

## 

# 设计原则

## 封装变化

> 找出应用中可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混合在一起

- 把会变化的部分取出来并"封装"起来,好让其他部分不会受到影响
- 即,如果每次新的需求到来,都会使得某方面的代码发生变化, 即确定,该部分的代码需要被抽取出来

**举例**

例如需要为Duck父类增加一个新的需求，fly方法。

错误的做法：

- 在父类增加方法。这个时候，由于Duck的子类有一些事不需要fly的，例如橡皮鸭。此时就又需要去子类当中重写覆盖。
- 新增一个fly的接口，但是此时由于接口不包含实现代码，因此需要在所有子类当中复现，更显繁琐

正确的做法：

- 将动作分离出来成为一个behave的类，然后与Duck做一个组合

## 合成复用原则

> 多用组合，少用继承

尽量使用对象组合，而不是通过继承来达到复用的目的。

## 接口分离原则

> 针对接口编程,而不是针对实现编程
>
> 不应该强迫客户依赖于它们不用的方法。

- 该设计原则关注于类的扩展性，针对接口编程时，在运行时就可以使用该接口引用不同的子类，运行时动态改变。
- 面对一个可能存在变化的类,将其变化抽出来制作一个接口,并针对接口进行不同的实现,从而使得类在"运行时"动态地"改变"
- 这个抽离的接口可以被复用，因为他们的行为已经和原来的类没有了关系
- 通过如此设计，我们可以新增行为，不会影响到既有的行为类，也不会影响“使用”到该行为的类
- 关键在于，现在这样的行为是委托给别人处理，而不是使用定义在父类或者子类内的方法

## 为了使交互对象之间松耦合而努力

> 

## 开放封闭原则

> 类应该对扩展开放，对修改关闭

软件实体应当对扩展开放，对修改关闭。

- 抽象是关键。如果没有抽象类或接口系统就没有扩展点
- 封装可变性。将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂到一起，系统将变得复杂混乱

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

## 依赖抽象，不依赖具体类

> 

## 里氏替换原则

> 任何时候都可以用子类型替换掉父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类的能力更多，把能力多的对象当成能力少的对象当然没有任何问题。

## 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
> 抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

## 最少知识原则

> 迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

只和你的密友谈话

- 当设计一个系统时，需要注意与它交互的类有哪些，并注意它和这些类是如何交互的。
- 不要让太多的类耦合在一起。

*实现方法*：

就任何对象而言，在该对象的方法内，只应该调用属于以下范围的方法

- 该对象本身
- 被当做方法的参数而传递进来的对象
- 此方法所创建或实例化的任何对象
- 对象的任何组件

```Java
//调用从另一个调用中返回的对象的方法
//不采用该原则，这样相当于向另一个对象的子部分发出请求
//因此需要认识该对象的组件，不符合将朋友圈维持在最小状态
public float getTemp(){
    Thermometer thermometer = station.getThermometer();//从气象站取得温度计
    return thermometer.getThermometer();//从温度计获取温度
}
//采用该原则
//在station当中加入方法，直接获得温度
public float getTemp(){
    return station.getThermometer();
}
```

*缺点*

虽然减少了对象间的依赖，减少了软件的维护成本。但是导致更多的“包装”类被制造出来，以处理和其他组件的沟通，可能导致复杂度、开发时间增加，降低运行时性能

## 别找我，我会找你

> 由超类主控一切，当他们需要的时候，自然回去调用子类。

给出一种防止“依赖腐败”的方法。当高层组件依赖底低层组件，低层组件又依赖高层组件，而高层组件又依赖边侧组件，边侧组件又依赖低层组件时，即依赖腐败。没有人可以轻易搞懂系统如何设计的

该原则下，允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么样使用这些低层组件。即低层组件不可用直接调用高层组件

***实现***

在模板方法模式当中，模板类拥有着算法。只有在需要子类实现某个方法时，才调用子类。

客户代码只依赖于模板方法，而不依赖于具体的类，减少了整个系统的依赖。

如果子类没有先被调用，绝对不会直接调用抽象类。（在客户代码中，引用的是抽象类型，因此依赖就大大减少。、）

## 单一责任原则

> 一个类应该只有一个引起变化的原因。即一个类只做它该做的事情（高内聚）
>
> 单一责任原则

- 当我们允许一个类不但要完成自己的事情（管理某种聚合），还同时要担负更多的责任（如遍历）时，就给了这个类**两个**变化的原因
  - 当集合改变时，这个类必须改变，当遍历的方式改变的话，这个类也必须跟着改变。当有两个变化的原因，会使得该类的变化几率上升。

- 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
  - 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

*解决*

将一个责任只指派给一个类。实现高内聚

## 共同封闭原则

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

## 稳定抽象原则

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

## 稳定依赖原则 

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

# 某些有趣的事情

- 和大佬们交流，使用观察者模式、策略模式等词，表述地更为方便一些
- 但是书里面有一个趣谈：写一个helloWorld也和模式挂钩，hhhhh代表着模式病

# 参考 #

1. [head first 设计模式]

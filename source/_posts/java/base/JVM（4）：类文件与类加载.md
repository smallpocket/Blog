---
title: JVM（4）：类文件与类加载
type: tags
tags:
  - null
date: 2019-03-01 10:46:32
categories:
description:
---

# 类文件结构

代码编译的结果从本期机器码转变为字节码，是存储格式发展的一步

## 概述

计算机只能识别0和1，因此程序需要经编译器翻译成二进制格式。越来越多程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式

## 无关性的基石

- 平台无关系
  - 许多虚拟机都可以载入和执行同一种平台无关的字节码，实现“一次编写，到处运行
  - 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式--字节码，是构成平台无关系的基石

- 虚拟机的另一种中立特性，即语言无关性，
  - 其他语言也可以允许在JVM上。Java虚拟机不和任何语言绑定，只与Class文件这种特定的二进制文件格式关联
  - Class文件包含JVM指令集和符号表以及若干其他辅助信息。基于安全，要求Class文件使用许多强制性的语法和结构化约束
  - Java语义最终都是由多条字节码命令组合而成。字节码所能提供的语言描述能力比Java更强大。

## Class类文件结构

- Class文件是一组以8字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分割符，使得Class文件中存储的内容几乎全部是程序允许的必要数据，没有空隙存在
- 当遇到需要占用8字节以上空间的数据项时，则按照高位在前的方式分割成若干个8位字节进行存储
  - 高位在前：最高位字节在地址最低位，最低位字节在地址最高处
- Class文件格式采用类C语言结构体的伪结构存储数据
  - 两种数据类型：无符号数，表
  - 无符号数：基本的数据类型，描述数字、索引引用、数量值或按UTF8编码的字符串值
  - u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数
  - 表：由多个无符号数或其他表构成的符合数据结构，以_info结尾。用于描述具有层次关系的符合结构的数据

**魔数与Class文件版本**

- 魔数：Class文件的头4个字节。用于确定文件是否为一个能够被虚拟机接受的Class文件
- 5-8字节：Class文件的版本号，5-6字节：次版本号，7-8字节：主版本号

**常量池**

跟在主次版本号之后的是常量池入口。

- 常量池可以理解为Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用空间最大的数据项目之一，同时是Class文件中第一个出现表数据项目
- 常量池主要存放两大类常量
  - 字面量。文本字符串、声明为Final的常量值
  - 符号引用。类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

虚拟机加载Class文件会进行动态连接，即Class文件不会保存各个方法、字段的内存最终布局信息。因此需要通过运行期转换才能得到真正的内存入口地址。

当虚拟机允许时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址之中。

**访问地址**

位于常量池之后，紧接的两个字节代表访问标志，标志用于标识一些类或者接口层次的访问信息。如该Class是类还是接口，是否为public等

**类索引、父类索引与接口索引集合**

类索引、父类索引：一个u2类型的数据

接口索引的集合：一组u2类型的数据

用于确定类的继承关系

**字段表集合**

用于描述接口或者类中声明的变量。字段包括类级变量以及实例级遍变量，但不包括在方法内部声明的局部变量

**方法表集合**

与字段表几乎一致

**属性表集合**

Class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息

## 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表某种特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）而构成。

Java虚拟机采用面向操作数栈而不是寄存器的架构，因此大多数指令不包含操作数

Class文件格式放弃了长度对齐，处理超过一个字节的数据时，不得不在运行时从字节中重建具体数据的结构。尽管需要解释执行字节码时损失一些性能，但是可以节约很多空间。

**字节码与数据类型**

在Java虚拟机的指令集中，大多数指令都包含了其操作所对应的数据类型信息。iload用于从局部变量表中加载int类型的数据到操作数栈中，fload加载float数据。两条指令的操作在虚拟机内部可能由同一段代码实现，但在Class文件中必须拥有各自独立的操作码。

对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊注明专门为哪种数据类型服务。i代表int，l代表long等。

**...待续**

## 公有设计与私有实现



# 虚拟机类加载引擎

## 概述

虚拟机如何加载Class文件？Class文件中的信息进入虚拟机后会发生什么变化

类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

Java里，类型的加载、连接和初始化过程都是在程序允许期间完成的，虽然使得类加载时稍增加一些性能开销，但是为应用提供高度灵活性。这实现了Java可以动态扩展的语言特性。

- 编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类
- 用户可以通过Java预定义的和自定义的类加载器，让一个本地应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分

Class文件：一串二进制字节流

## 类加载 的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期：

加载、验证、准备、解析、初始化、使用、卸载

![1552289027554](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552289027554.png)

加载、验证、准备、初始化、卸载的顺序是确定的，依次顺序开始（只是开始，不是进行或者完成，他们中间混合交叉进行）。而解析阶段不一定，它在某些情况下可以在初始化之后再开始，以支持动态绑定

**立即对类进行初始化的情况**

有且只有：

这5中场景中的行为称为对一个类进行主动引用，除此外，所有引用类的方式都不会触发初始化，称为被动引用。

- 遇到new、getstatic、putstatic、invokestatic的字节码指令，如果类没有初始化，则需要先触发其初始化
- 遇到java.lang.reflect包的方法对类进行反射调用时
- 当初始化一个类，如果其父类还没有进行初始化，则先父类初始化（如果是接口，则不要求父类接口全部完成初始化，只有真正使用到父类接口时才会初始化）
- 当虚拟机启动时，用户需要指定一个主类，先初始化主类
- ![1552290936413](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552290936413.png)

## 类加载的过程

### 加载

- 通过一个类的全限定名来获取定义此类的二进制字节流
  - 读取途径
    - 从ZIP包读取，成为日后JAR格式的基础
    - 从网络中获取，如applet
    - 运行时计算生成，动态代理技术，java.lang.reflect.Proxy
    - 由其他文件生成，如JSP，由JSP文件生成Class类
    - 从数据库中读取等
  - 开发人员可控性最强（非数组类）
    - 可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成，重写一个loadClass()方法
  - 数组类：由JVM直接创建，不由类加载器创建。但是内部的元素由类加载器创建。一个数组类C的创建过程：
    - 如果数组的组件（即数组去掉一个维度的类型）是引用类型，则递归加载这个组件类型，数组C将在加载该组件类型的类加载器的类名空间上被标识
    - 如果不是引用类型，Java虚拟机将在数组C标记为与引导类加载器关联
    - 数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那么数组类的可见性默认为public
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 验证

连接截短的第一步，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全

**文件格式验证**

验证字节流是否符合Class文件格式的规范，并能够被当前JVM处理

- 是否以魔数开头
- 主次版本号是否在当前虚拟机处理范围内
- 常量池的常量是否有不被支持的常量类型
- 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量
- 文件中各个部分已经文件本身是否有被删除或附加的其他信息

只有该阶段直接操作字节流，其他三个验证阶段都是基于方法区的存储结构进行的

**元数据验证**

对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范

- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类
- 如果这个类不是抽象类，是否实现了父类或接口中要求的所有方法
- 类中的字段、方法是否与父类矛盾

**字节码验证**

目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。

对类的方法体进行校验分析，保证方法在运行时不会做出危害虚拟机安全的事件

- 保证方法体中的类型转换时有效，不会出现对象赋值给与它无关的数据类型
- 保证跳转指令不会跳转到方法体以外的字节码指令上

**符号引用验证**

发生在虚拟机将符号引用转化为直接引用的时候，这个转化在解析阶段发生

对类自身以外的信息进行匹配性校验。

- 通过字符串描述的限定名是否能找到对应的类
- 符号引用中的类、字段、方法的访问性是否可以被当前类访问

确保解析动作能够正常执行

### 准备

正式为类变量（static的）分配内存并设置类遍历初始值（0值）的阶段，这些变量使用的内存都将在方法区中进行分配。

### 解析

虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。以字面量形式定义在Class文件中
- 直接引用：直接指向目标的指针、相对偏移量或一个能够间接定位到目标的句柄。

对于同一个 符号引用进行多次解析是常见的，除invokedynamic指令外，虚拟机实现对第一次解析的结果进行缓存（缓存：在运行时常量池中记录直接引用，并将常量标识为已解析状态），从而避免解析重复进行。

虚拟机需要保证在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。如果第一次失败了，那么其他指令对这个符号的解析请求也应该收到同样的异常

invokedynamic指令用于动态语言支持，只有当实际运行到该节点，才开始解析。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号

### 初始化

- 初始化真正开始执行类中定义的Java程序代码。执行类构造器\<client>（）方法的过程
- \<client>方法由编译器收集类中所有类遍历的赋值动作与静态语句块的语句合并而成，顺序由出现顺序而定。
- \<client>方法与类构造函数不同，不需要显式调用父类构造器，虚拟机保证在此前，父类的\<client>方法已经执行完毕
- 虚拟机会保证一个类的\<client>方法会在多线程环境正确被加锁、同步。多个线程同时初始化一个类，只有一个线程去执行该方法，其他线程阻塞

## 类加载器

将类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”的动作放到虚拟机外部实现，以便让程序自己决定如何获取所需要的类。实现该动作的代码模块为类加载器。

### 类与类加载器

类加载器用于实现类的加载动作。

- 对于任意一个类，都需要由加载它的类加载器与这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间
- 判断两个类是否相等，只有两个类是由同一个类加载器加载的前提下才有意义
- 相等：equalis等方法返回的结果

### 双亲委派模型

从Java虚拟机角度讲，只存在两种不同的类加载器

- 启动类加载器，使用C++实现，是虚拟机自身一部分
- 所有其他的类加载器，Java实现，独立于虚拟机外部，并全部继承自抽象类java.lang.ClassLoader

从程序员角度讲

- 启动类加载器。负责将类库加载到虚拟机内存当中，该加载器无法被Java程序直接引用。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可
- 扩展类加载器。负责加载\<JAVA_HOME>\lib\ext目录，或者java.ext.dirs系统变量指定的路径中所有类库，开发者可以直接使用扩展类加载器
- 应用程序（系统）类加载器。负责加载用户类路径上指定的路径，可以直接使用这个类加载器，并且是程序中的默认加载器

![1552378339303](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552378339303.png)

要求除了顶层的启动类加载器，其余的类加载器都应当有字节的父类加载器。父子关系一般不会以继承关系实现，而都是以组合关系来复用代码。

工作过程：

- 如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此既
- 所有的加载请求都会传送到顶层的启动类加载器，只有父类无法完成这个加载请求，子加载器才会尝试自己去加载

优势：

- Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如Object类，任何一个类加载器加载这个类，都委派给了启动类加载器，因此他们都是同一个类。而如果让各个类去自行加载，那么系统会出现多个不同的object类。

实现：

- 先检查是否已经被加载过
- 如果没有，则调用父类的loadClass
- 若父加载器为空，则默认使用启动类加载器作为父加载器
- 如果父加载失败，抛出异常，则调用字节的findClass方法加载

### 破坏双亲委派模型



# 虚拟机字节码执行引擎

# 参考 #

1. 

---
title: JVM（2）：内存管理
type: tags
tags:
  - null
date: 2019-03-01 10:45:42
categories:
description:
---

# java内存区域与内存溢出异常

Java将内存扩展的权利交给了jvm，虚拟机自动内存管理机制的帮助下，不再需要为每个new操作写配对的delete/free代码，不容易出现内存泄露与内存溢出问题。如果出现问题，如果不了解JVM如何使用内存，那么排查错误将会成为一项异常艰难的工作

## 运行时数据区域

- Java虚拟机在执行Java程序的过程中，会将它管理的内存划分为若干个不同的数据区域
- 区域有各自的用途、创建时间、销毁时间。
- 有的区域随着虚拟机进程的启动而存在，有的区域一来用户线程的启动和结束而建立和销毁

区域包括

- 方法区
  - 各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  - Non-Heap、永久代
  - **运行时常量池**（方法区的一部分）
    - 存放编译期生成的各种字面量和符号引用
- 堆
  - 虚拟机管理的内存中最大的一块，在虚拟机启动时创建，所有线程共享
  - 存放对象实例，几乎所有对象实例都在这里分配内存
  - 垃圾收集器管理的主要区域，也称为GC堆
    - 从内存回收的角度，使用分代收集算法
    - 堆可分为新生代和老年代
    - Eden空间、From Survivor空间、To Survivor空间
  - 从内存分配的角度
    - 划分出多个线程私有的分配缓冲区TLAB
  - 当堆无法再扩展OutOfMemoryError
- 虚拟机栈
  - 线程私有，生命周期与线程相同
  - 描述Java方法执行的内存模型（栈内存）
    - 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用至完成则对应一个栈帧在虚拟机栈入栈到出栈
  - 线程请求栈深度大于虚拟机允许深度，StackOverflowError异常
  - 大部分虚拟机允许动态扩展，如果扩展无法申请到足够内存，则OutOfMemoryError
- 本地方法栈
  - 虚拟机使用到的Native方法服务，不一定是Java实现的
- 程序计数器
  - 一块较小的内存空间（线程私有）
  - 当前线程所执行的字节码的行号指示器，字节码解释泣工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令
    - 分支、循环、跳转、异常处理、线程恢复等基本功能
  - CPU通过时分复用实现多线程，对确定时刻，一个CPU只会执行一条线程中的指令。每个线程都有一个独立的程序计数器。
- 直接内存
  - 不是虚拟机运行时数据区的一部分，也不是JVM定义的内存区域
  - NIO，基于通道与缓冲区的IO方式，使用Native函数库直接分配堆外内存，通过一个堆中的对象引用
    - 避免了在Java堆与native堆中来回复制
  - 不受Java堆大小限制，受本机总内存等限制

## Hotspot虚拟机对象揭秘

虚拟机内存中的数据如何创建、如何布局、如何访问等问题

揭秘Hotspot虚拟机在Java堆中对象分配、布局和访问全过程

### 对象的创建

对于普通的Java对象，不包括数组和Class对象

- 虚拟机遇到一条new指令，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查一个符号引用代表的类是否已经被加载、解析和初始化过
- 如果没有，则必须先执行相应的类加载过程
- 为新生对象分配内存，所需内存在类加载完成后便可完全确定。将一块大小确定的内存从Java堆当中划分出来
  - 划分内存的方法
  - 指针碰撞：Java堆中内存绝对规整（所有已用在一边，空闲在另一边），中间一个指针作为分界点的知识点，即将指针向空闲移动一段距离
  - 空闲列表：内存不规整，维护一个记录可用内存的列表，分配一个足够大的空间
  - 内存是否规整由垃圾收集器是否带有压缩整理的功能决定
- 分配内存空间可能存在线程安全问题
  - 对分配内存空间的动作做同步处理
    - CAS配失败重试的方法
  - 把内存分配的动作按线程划分在不同的空间中进行
    - 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），线程在各自的TLAB上分配内存。当TLAB用完，才需要同步锁定。
- 虚拟机将分配到的内存空间初始化为0（不包括对象头）
- 对对象进行必要的设置，存放在对象头中。如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。根据JVM当前运行状态不同，是否启用偏向锁等。
- 对象进行init，进行构造

### 对象的内存布局

dioxide造内存中存储的布局分为三部分

- 对象头
  - 存储对象自身的运行时数据。哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
  - 类型指针。对象指向它类元数据的指针，JVM通过这个指针来确定这个对象是那个类的实例
    - 并不是所有JVM都实现，即查找对象的元数据不一定经过对象本身
  - 如果是数组，则记录数组长度的数据
- 实例数据
  - 对象真正存储的有效信息
  - 存储顺序受虚拟机分配策略参数与字段在Java源码中定义顺序的影响
    - longs/double、ints、shorts/chars、bytes/booleans、oops。相同宽度的字段被分配到一起
    - 父类变量会出现在子类前（CompactFields为true（默认），子类中较窄的遍历也可能插入到父类变量的空隙中）
- 对齐填充
  - 并不必然存在，起到占位符作用
  - Hotspot自动内存管理相同要求对象的其实对这必须为8字节的整数倍

### 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象。

解释引用通过何种方式去定位、访问堆中的对象的具体位置。依据JVM实现而定

- 句柄
  - Java堆当中划分一块内存作为句柄池，reference中存储的是对象的句柄地址
  - 句柄中包含了对象实例数据域类型数据各自的地址信息
  - 稳定的句柄地址，即使对象被移动（垃圾收集时，非常普遍），也不会修改reference
  - ![1552120017803](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552120017803.png)
- 直接指针
  - reference存储的就是对象地址
  - Java堆对象的布局中需要考虑如何放置访问类型数据的相关信息
  - 速度快，节约一次指针定位，对于非常频繁的对象访问有较好的提升。Hotspot使用的方式
  - ![1552120022744](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552120022744.png)

# 垃圾收集器与内存分配策略

## 概述

垃圾收集GC需要完成的三件事情：

- 哪些内存需要回收
- 什么时候回收
- 如何回收

无需关注的内存：对于程序计数器、虚拟机栈、本地方法栈。随线程而生灭，一个栈帧内分配多少内存基本上在类结果确定下来就已知，因此内存分配与回收都具备确定性。并且方法结束或者线程线束，内存就回收了。

GC关注的内存：对于Java堆和方法区，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只能在程序运行期间才能知道会创建哪些对象，分配与回收都是动态的。

## 对象是否存活

GC在对堆进行回收前，要确定这些对象中哪些还存活着，哪些已经死去（不可能再被任何途径使用的对象）

### 引用计数算法

定义：为对象添加一个计数器，每当有一个地方引用它时，计数器就++，引用失效时，计数器--

优点：实现简单、判定效率高

缺陷：难以解决对象间相互循环引用的问题

```Java
objA.instance=objB;
objB.instance=objA;
//相互引用，导致无法回收
```

### 可达性分析算法

Java等语言的主流实现

基本思想：

- 通过一系列称为GC Roots的对象作为起始点，从这些结点开始向下搜索，走过的路径称为引用链
- 一个对象到GC Roots没有任何引用链，即不可达，则对象不可用
- GC Roots对象：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈当Native方法引用的对象
- ![1552121101706](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552121101706.png)

### 引用

判断对象是否存活均与引用有关

- 强引用
  - 指在程序代码中还普遍存在，类似“Object o=new Object()”的引用，只要强引用还存在，则永不回收
- 软引用
  - 描述还有用，但并非必须的对象。在系统将内存溢出异常前，会将这些对象进行第二次回收。如果还没有足够内存，才会异常。
  - 以SoftReference类实现软引用
- 弱引用
  - 描述非必须对象，强度弱于软引用只能生存到下一次垃圾回收前
  - WeafReference实现
- 虚引用
  - 最弱的引用关系，无法通过虚引用获得一个对象的实例
  - 唯一母的是能在这个对象被回收时收到一个系统通知
  - PhantomReference实现

### 生存还是死亡

要宣告一个对象死亡，至少要经历两次标记过程

- 如果在可达性分析中，发现无连接，则进行第一次标记以及第一次筛选

- 第一次筛选，条件为此对象是否有必要执行finalize方法。

  - 没有必要执行的情况：

    - 对象没有覆盖finalize方法
    - finalize方法已经被虚拟机调用过

  - 有必要执行

    - 将对象放置在一个F-Queue队列，并在稍后由一个虚拟机自动建立，低优先级的finalizer线程去执行
    - 执行：虚拟机会触发这个方法，但并不承诺会等待它允许结束

      - 防止一个对象在finalize执行缓慢，或者死循环，使得其他对象等待
    - GC对F-Queue中对象进行第二次小规模标记，
    - finalize是对象最后一次自救机会，如果对象此时与引用链上一个对象建立关联，则此时将被移出“即将回收”集合

### 回收方法区

永久代的垃圾回收效率非常低

回收内容：

- 废弃常量
  - 常量池存在“abc”，无String引用引用，则为废弃常量
- 无用的类
  - 该类所有实例都被回收
  - 加载该类的ClassLoader被回收
  - 该类对应的Class对象没有被引用，无法通过反射访问该类的方法

## 垃圾回收算法

垃圾回收算法

### 标记-清除算法

最基础的算法，算法分为标记与清除两个阶段

- 标记出所有需要回收的对象，在标记完成后统一回收被标记的对象

不足：

- 效率低下
- 清除后会产生大量不连续的内存碎片

### 复制算法

解决效率问题

将可用内存按容量划分为两块，每次使用一块，一块内存使用完后，将其复制到另一块，然后回收

用于回收新生代

- 新生代对象98%朝生夕死，因此将内存分为一块较大的Eden空间与两块较小的Survivor空间（8：1）。
- 每次使用Eden空间与一块Survivor空间
- 当Survivor空间不够时，依赖其他内存（老年代）进行分配担保

### 标记-整理算法

标记过后，让所有存活的对象都向一端移动，然后清理端边界外的内存

### 分代收集算法

**实际采用的算法**

根据对象存活周期的不同将内存划分为几块：新生代、老年代

根据各个年代的特点采用适当的收集算法，新生代：复制算法，老年代：标记-清理（整理）算法

## HotSpot算法实现

以上是理论实现，而虚拟机高效允许需要对算法的执行效率进行严格的考量

### 枚举根节点

帮助快速准确完成GC Roots枚举

困难

- GC Roots的节点非常多，逐个检查引用需要小号非常多的时间
- GC停顿问题（GC进行时必须停顿所有执行线程），必须在一个确保一致性（整个执行系统冻结在某个时间节点，不可以出现在分析过程中，引用关系还在不断变化）的快照中进行

主流JVM使用准确式GC，当执行系统停顿下来，并不需要一个不漏检查完所有的引用位置，应当有办法直接得知哪些地方存放着对象引用

HotSpot使用OopMap达到目的，在类加载完成时，HotSpot将对象内什么偏移量是什么类型数据计算出来，在JIT编译时也会在特点位置记录栈和寄存器哪些位置是引用

### 安全点

- 引用关系可能变化，OopMap内容变化指令非常多，如果为每一条指令生成对应的OopMap则需要大量空间
  - 程序执行时只有在到达**安全点**时才能暂停，进行GC。
  - **安全点的选择**：以是否具有让程序长时间执行的特征为标准选定。即指令序列复用，如方法调用、循环跳转、异常跳转等
- 如何在GC发生时，让所有线程都跑到最近的安全点再停顿
  - 抢先式中断（几乎JVM使用）
    - GC发生时，首先把所有线程中断，如果线程不在安全点，就恢复线程，让它跑到安全点
  - 主动式中断
    - 当GC需要中断时，不直接对线程操作，设置一个标志（与安全点重合），各个线程执行时轮询这个标志，如果为真则自己中断挂起

### 安全区域

- 对于不执行的程序，如挂起或者blocked状态，无法响应中断请求，走到安全点。
  - 安全区域：在一段代码片段中，引用关系不会发生变化。则在这个区域的任意地方开始GC都是安全的
  - 当线程执行到安全区域时，标识自己已经进入安全区域，当JVM发生GC时，不用管已经标识的线程。当线程离开时，需要检查系统是否完成GC，如果完成则继续执行，否则继续等待

## 垃圾收集器

内存回收的具体实现

![1552131024681](C:\Users\Heper\AppData\Roaming\Typora\typora-user-images\1552131024681.png)

存在连线，则说明可以搭配使用。所处区域，说明属于新生代还是老年代收集器

为了对具体应用最合适的收集器

### Serial收集器

### ParNew收集器

### Parallel Scavenge收集器

### Serial Old收集器

### ParNew Old收集器

### CMS收集器

### G1收集器

### 理解GC日志

## 内存分配与回收策略

Java的自动内存管理自动化解决了两个问题

- 给对象分配内存
  - 主要分配在新生代的Eden区
  - 如果启动了本地线程分配缓冲，将线程优先在TLAB上分配
  - 少数情况直接分配到老年代中
  - 分配规则取决于当前使用哪一种垃圾回收器组合，还要虚拟机中与内存相关的参数的设置
- 回收分配给对象的内存

### 对象优先在Eden分配

大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC

- 新生代GC（Minor GC）指发生在新生代的垃圾回收动作，因为Java对象大多具备朝生夕死的特性，所以该GC频繁，且速度快
- 老年代GC（Major GC/Full GC）指发生在老年代GC，比新生代GC慢10倍以上

### 大对象直接进入老年代

大对象：需要大量连续内存空间的Java对象，例如很长的字符串与数组

经常出现大对象容易导致内存还有不少空间时就需要提前触发垃圾收集以获得连续空间

### 长期存活的对象进入老年代

虚拟机为每个对象定义了一个对象年龄Age计数器，每经过一次Minor GC则age+1，当达到15（MaxTenuringThreshold设置）则升级到老年代

### 动态对象年龄判定

为了更好适应不同程序内存情况，并不是永远要求年龄到达阈值才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小总和大于空间的一般，年龄大于等于该年龄的对象就可以直接进入老年代

### 空间分配担保

- 在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
  - 如果大于，则Minor GC可以确保安全
  - 如果不大于，则虚拟机查看HandlePromotionFailure设置值是否允许担保失败
    - 允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
      - 如果大于则尝试进行Minor GC,尽管有风险
      - 如果小于，或者HandlePromotionFailure不允许冒险，则进行一次Full GC

# 参考 #

1. 

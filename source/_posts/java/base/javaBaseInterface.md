---
title: javaBaseInterface
type: tags
date: 2018-09-23 10:30:29
categories: java
tags:
- JavaBase
description: java笔记的基础知识整理，SE的接口与引用的一些知识
---
# 接口

接口用于描述类的功能

## 接口的实现

- 使用 Interface关键字
- 可以定义常量（public static final），但是不能定义实例域
- 在SE8之后可以定义方法，但是不能使用实例域，因为没有实例

### 默认方法

为接口的方法提供一个默认的实现

```java
/**
 * 所有继承了该接口的方法，如果没有重写该方法，则会使用默认实现
 * 可以将全部方法声明为默认实现，则就只需要去重写真正需要的方法
 */
default int compareTo(T other){
	return 0;
}
```

实现“接口演化”

- 如果为一个接口新增了一个方法，那么所有实现该接口的类都要去覆盖这个方法，就会导致旧版代码的不兼容性。
- 使用默认实现，则以前的类并不需要去覆盖该方法，只有有需求的类才会去覆盖

## 实现了接口就履行了合约 ###

1.履行合约的方式是去定义相关的方法  
2.履行了合约,即可去实现与合约相关的动作,实现类似继承和多态

# 对象克隆Cloneable接口

克隆一个对象并不能简单的让一个引用去等于另一个引用，因为它们将指向同一个对象。

若想让它们在初始状态相同，而在之后会发生独立的改变，则需要对对象进行克隆。

若想对对象进行克隆，则需要使用clone方法，clone方法是Object的一个protected方法，因此，假设有Employee类，则只有Employee类才能clone Employee类。

## 克隆的困难

- 如果类本身只有一些基础数据类型，则clone并无问题
- 如果类里面存在着对其他对象的引用，那么拷贝便会将子类的引用拷贝过去，那么便会是不安全的浅层拷贝，并没有完全的独立
- 实现深克隆需要实现Cloneable接口


# 抽象类 #

1.某些类根本无法初始化,比如说animal类,那类似于这种应该作为一个抽象类abstract,或者说是一个接口   
2.抽象类可以拥有抽象方法和非抽象方法    
3.抽象方法没有实体
***



### 关于引用的一些问题 ###

	ArrayList<Object> myDogArrayLust = new ArrayList<Object>();   
	Dog aDog =new Dog(); 
	MyDogArrayList.add(aDog); 
	Dog d=myArrayList.get(0);!!!!报错     

#### 解析 ####

1.不管放进去了什么,出来也只是Object,除非使用了泛型,标明了类型   
2.传递过程,传递进去一个Dog类型,然后由于参数是Object,父类引用子类,成功add,但是取出的时候, return的参数也是Object    
3.因此说,里面确实存放的是一个包含Dog属性的类型,但是获取的却是一个Object的引用,那么根据多态,子类是无法引用父类的    
4.同样,如果调用一个.eat()方法,那么首先这是一个Object类型的引用,编译器会去寻找Object类及其父类(当然是没有了)的eat()方法,很明显的问题,是不存在的  
5.因为对于编译器来说,当你传递进去的时候,它是它原来的类型,取出来的时候,它确实是一个Object类型,而不是引用了其他类型,编译器只根据引用的类型,而不是对象的类型   
***

- 强制类型转换使用instanceof可以检验是否可以成功转换类型`o instanceof Dog`转换成功返回true



